# scheme

**Эту задачу нужно решать, после задач scheme-tokenizer и scheme-parser**

В этом задании вам предстоит реализовать интерпретатор для
lisp-подобного языка программирования, а именно некоторого подмножества scheme. 

Язык будет состоять из:
 - Примитивных типов: целых чисел, bool-ов и _символов_ (идентификаторов).
 - Составных типов: пар и списков.
 - Переменных с синтаксической областью видимости.
 - Функций и лямбда-выражений.

Ваша программа должна будет выполнять выражения языка и возвращать результат выполнения.

```
    1 => 1
    (+ 1 2) => 3
```
Обозначение `=>` в примерах здесь и далее разделяет выражение и результат его выполнения.

## Выполнение выражений
Выполнение языка происходит в 3 этапа:

**Токенизация** - преобразует текст программы в последовательность
   атомарных лексем. 

**Синтаксический анализ** - преобразует последовательность токенов
   в [AST](https://en.wikipedia.org/wiki/Abstract_syntax_tree).  AST в
   лисп-подобных языках программирования представляется в виде
   списков. 
   
**Вычисление** - рекурсивно обходит AST программы и преобразует его
   в соответствии с набором правил.

### Пример

Выражение 
```
    (+ 2 (/ -3 +4))
``` 
в результате токенизации превратится в список токенов:
```
    { 
        OpenParen(),
        Symbol("+"),
        Number(2),
        OpenParen(),
        Symbol("/"),
        Number(-3),
        Number(4),
        CloseParen(),
        CloseParen()
    }
```
     
 Последовательность токенов в результате синтаксического анализа
 превратится в дерево:
     
```
    Cell{
        Symbol("+"),
        Cell{
            Number(2),
            Cell{
                Cell{
                    Symbol("/"),
                    Cell{
                        Number(-3),
                        Cell{
                            Number(4),
                            nullptr
                        }
                    }
                }
                nullptr
            }
        }
    }
```
Результатом же выполнения выражения будет 

```
    (+ 2 (/ -3 +4)) => 1
```


## Обработка ошибок

* Ваш интерпретатор должен различать 3 вида ошибок:

  1. SyntaxError - ошибки синтаксиса. Возникают когда программа не соответствует
     формальному синтаксису языка. Или когда программа неправильно
     использует особые формы.

  2. NameError - ошибки обращения к неопределённым переменным.

  3. RuntimeError - ошибки времени исполнения. К этим ошибкам относятся все остальные
     ошибки которые могу возникнуть во время выполнения
     программы. Например: неправильное количество аргументов передано в
     функцию, неправильный тип аргумента.

## Дополнительные материалы

* Видео-урок [введение в scheme](https://www.youtube.com/watch?v=AqBxU-Zmx00) объяснит базовые конструкции языка.

* [Слайды](../docs/scheme/scheme.md) с семинара

* Для погружения в язык стоит воспользоваться интерактивным интерпретатором.
Такого рода среды программирования называются REPL (read-eval-print loop) и существуют для самых разных языков программирования. 
[REPL для BiwaScheme](https://repl.it/languages/scheme) - поэкспереминтируйте в нём с выполнением выражений, разберитесь с польской нотацией, синтаксисом языка.
К сожалению, не существует каноничной реализации языка, все реализации обладают своим уникальным набором фичей и багов. Пример другого интерпретатора [compile scheme online](https://rextester.com/l/scheme_online_compiler).
Готовые интерпретаторы предлагаются только для ознакомления с языком, вам же предстоит написать свой язык.

## Указания по реализации

* Списки должны строиться из пар, как обсуждалось на семинаре. В реализации вам 
может быть удобно работать со списком как с вектором, для этого можно написать
хелпер трансформирующий одно представление в другое.

* Для представления чисел используйте целочисленный тип int64_t,
считайте что переполнение не происходит.

* Разберитесь с представлением основных структур данных в вашей программе.
Разберитесь с тем, как должен быть реализован list.

* Продумайте стратегию управления памятью. Используйте std::shared_ptr.
Можете не думать о разрешение циклических ссылок из std::shared_ptr, так как
в этой задаче отключена проверка на утечку памяти.
На реализацию сборщика мусора есть отдельная [бонусная задача](../scheme-no-leaks)

* Не пишите весь код в одном файле. В этой задаче вы можете создавать свои .h и .cpp
файлы в папке `scheme/`

## Further reading

* Книга [Build Your Own Lisp](http://www.buildyourownlisp.com/) разбирает детали
реализации интерпретатора на языке C.

* Книга [Crafting Interpreters](http://craftinginterpreters.com/) разбирает реализацию
интерпретатора для более сложного языка, чем lisp.
